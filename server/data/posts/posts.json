[
  {
    "id": "009wer9wer8akjhsda",
    "postTitle": "Using NgModelController $validators and $asyncValidators to validate form fields",
    "postAuthor": "Yakira Bristol",
    "postDate": "4.30.2016",
    "postTags": "AngularJS | Validation | Javascript",
    "postSnippet": "The most common way to validate form fields in angular is to look at <code>$valid</code> and <code>$invalid</code> on the fields. But what if that is not enough and you want to create special validation for your fields (i.e. validating an email against a regex or make a call to the server to validate a value)? <code>NgModelController</code> has collection of validators called <code>$validators</code> and <code>$asyncValidators</code> that can be used to create your custom field validations...",
    "postBody": "<div> <p> In validating form input fields, we wanted to create a directive that would handle the validation of an email. The most common way to do this would be to look at <code>$valid</code> and <code>$invalid</code> on the field. But what if that is not enough and you want to validate an email against a regex or make a call to the server to validate a value? When you use <code>NgModel</code> on a directive, <code>NgModelController</code> has a collection of validators called <code>$validators</code> that can be used to create your custom field validations.</p> <p> This can be accessed in the link function and set for the field you would like to validate. <code data-gist-id=\"f71e72bc81f7382843f099afba677164\" data-gist-show-spinner=\"true\"></code></p> <p> What if you needed to make that call to the server to validate? You would use <code>asyncValidators</code>. <code data-gist-id=\"d5b9d402e7a2d9ab88853e1c78e5b5cb\" data-gist-show-spinner=\"true\"></code></p> <p> One caveat is that every time you type in the input, the call to the server is being made. To alleviate this use <code>ng-model-options</code> to update the behavior of the validation.</p> <p> These can be set on the field: <code data-gist-id=\"638367bd374f55b9d8f372aa697d2e71\" data-gist-show-spinner=\"true\"></code></p> <p> What these options say is that we want to update on default, update on blur, set the <code>debounce</code> default to 300 ms and blur. The really important part here is <code>debounce</code>. What <code>debounce</code> says is that we only want the validation to occur if no input has been entered after 300ms or a blur occurs on the input field. This allows the user to keep typing without being interrupted with validation errors and we make fewer calls to the server for validation.</p> <p> These can also be added in the link function. <code data-gist-id=\"bfcdee582b2bad79452679f7a9b6988e\" data-gist-show-spinner=\"true\"></code></p> <p> It is preferable to set default options in the link function and allow anyone using your directive to set their own options on the input field. <code data-gist-id=\"900ff593b3ca2d74443b1c2f54d10a2b\" data-gist-show-spinner=\"true\"></code></p> <p> <code>angular.merge</code> performs a deep copy of the object as opposed to <code>angular.extend</code> which performs a shallow copy of the object. We will discuss the different functions provided by Angular in a future post.</p> <p> Now that we have your custom validation in place for an email, we can create more and add them to the <code>$validators</code> or <code>$asycValidators</code> property. Maybe we want to have a unique email validator or put validation on a password. That can all be done by adding them to the appropriate property on <code>NgModelController</code>.</p> <p> How do you validate form fields? Let us know in the comments below.</p> </div>"
  },
  {
    "id": "009wer9wer8akjhsdf",
    "postTitle": "Using BindToController - Why is this so damn useful?",
    "postAuthor": "Josh Gonzalez",
    "postDate": "5.20.2016",
    "postTags": "AngularJS | Components | Directives | Javascript",
    "postSnippet": "<code>BindToController</code> allows you to bind the components properties directly to <code>Controller</code> rather than the <code>isolated $scope</code> of the component. This is a huge win for component development! The controller of the component now has the ability to be decoupled...",
    "postBody": "<div> <p> <code>BindToController</code> allows you to bind the components properties directly to <code>Controller</code> rather than the <code>isolated $scope</code> of the component. This is a huge win for component development! The Controller of the component now has the ability to be decoupled from the component <code>isolated $scope</code>. There is now no reason to have a messy mixing of <code>$scope</code> and the context of the Controller. </p> <p> Before we get into the code, this is how Angular defines the <code>BindToController</code> property: </p> <blockquote> <a rel=\"_blank\" href=\"https://docs.angularjs.org/api/ng/service/$compile\">BindToController</a> - This property is used to bind scope properties directly to the Controller. It can be either true or an object hash with the same format as the scope property. Additionally, a controller alias must be set, either by using controllerAs: 'myAlias' or by specifying the alias in the controller definition: controller: 'myCtrl as myAlias'. </blockquote> <p> Ok, so what exactly does this mean? This means that we can remove the passing and binding of <code>$scope </code> through out our <code>controller/directive</code>. </p> <hr /> <h3>The Messy Way</h3> <p> Below is an example of this <em>(working example can be found here -> <a rel=\"_blank\" href=\"http://codepen.io/refinedjs/pen/dMBLqb/?editors=1011\">Code Pen</a>)</em>. </p> <code data-gist-id=\"1fb1731c3c9f362d63c1049127210f44\" data-gist-show-spinner=\"true\"></code> <hr /> <h3>The Refined Way</h3> <p> To clean up the code above and to make more sense of what we are using we will incorporate the <code>BindToController</code> property. The <code>BindToController</code> property can be either a True/False or an object hash. Also, the <code>ControllerAs</code> property must be set in order to use <code>BindToController</code>. With these to properties set, we can not have Angular bind the given properties to the controller rather the <code>$scope</code>. </p> <p> In our example, we will be using the an object hash, by using the hash, this tells Angular to set up bindings to the controller directly. <strong>**One important thing to note</strong>, If <code>BindToController</code> and <code>$scope</code> are both defined with object hashes, <code> BindToController</code> will override the components <code>$scope</code>. </p> <p> Below you can see this in action <em>(working example can be found here -> <a rel=\"_blank\" href=\"http://codepen.io/refinedjs/pen/ONeYJm?editors=1011\">Code Pen</a>)</em>. </p> <code data-gist-id=\"46a1eefa119c2d550b1c5413f8a2646b\" data-gist-show-spinner=\"true\"></code> <p> As you can see from the code example above that <code>BindToController</code> makes it easier and more elegant option when using Controllers in Directives/Components. This is a fairly basic example; however, it gives good insight into the property as a whole. Please comment any suggestions or better ways to use the <code>BindToController</code> property. </p> </div>"
  },
  {
    "id": "009wer9wer8akjhssd",
    "postTitle": "In too deep? - Deep copying objects in Angular",
    "postAuthor": "Yakira Bristol",
    "postDate": "6.4.2016",
    "postTags": "AngularJS | Objects | Functions | Javascript",
    "postSnippet": "With jQuery, we learned to copy objects using <code>jQuery.extend()</code>. What if we want to do this in Angular, in which using jQuery should be avoided? Angular has a function that can be used, like <code>jQuery.extend()</code>, called <code>angular.extend()</code>. But that just scratches the surface...",
    "postBody": "<div> <p> Let&apos;s say you had object <code>{obj}</code>. You want to modify the values to create a new Kryptonian, but you want to keep the original state of your object. To do this, you can make a copy of the original object and modify the copy however you would like. With jQuery, we learned to copy objects using <code>jQuery.extend()</code>. In use, <code>jQuery.extend({}, originalObj)</code> says, take my original object and make a copy into a brand new empty object. If you want to preserve default values you can copy the original along with a new object that changes some of the defaults and adds new properties using <code>jQuery.extend({}, originalObj, newObj)</code>. <code data-gist-id=\"7d5e39f4d3375afe20c54171c9030d87\" data-gist-show-spinner=\"true\"></code> </p> <p> You can check out additional examples here -> <a rel=\"_blank\" href=\"https://api.jquery.com/jquery.extend/\">jQuery.extend()</a> </p> <p> What if we want to do this in Angular, in which using jQuery should be avoided? Angular has a function that can be used, like <code>jQuery.extend()</code>, called <code>angular.extend()</code>. But that just scratches the surface. It performs only a shallow copy of an object in which you only have a copy of top level parent properties on an object. jQuery does have a <code>deep</code> boolean you can pass into its extend function that specifies a deep or non-deep copy, but that only goes down so far and misses children of children of children. We would have to write our own deep copy of an object. Objects can have infinite levels and for that we need <code>angular.merge()</code> which performs a true deep copy of an object. </p> <p> Suppose we had an object we wanted to copy. <code data-gist-id=\"2ac8f13561f6f7fdfa25f8e46ef4a1bd\" data-gist-show-spinner=\"true\"></code> </p> <p> Complicated right? If we want to deep copy it in jQuery we would have to grab each property, cycle through them and create a copy in a new object. sically recursion. With Angular all you have to use is <code>angular.merge({}, originalObj)</code>. It does the recursive work for you hitting all levels of your object. If you want to preserve your defaults and copy the original along with a new object that changes some of the defaults, you can use <code>angular.merge({}, originalObj, newObj)</code>. No more complicated custom functions for deep copying objects. If that is your thing, hey, go for it! Just know that Angular can do the work for you. Why reinvent the wheel, eh? </p> </div>"
  },
  {
    "id": "009wer9wer8akscvt",
    "postTitle": "Read the source code",
    "postAuthor": "Yakira Bristol",
    "postDate": "4.11.2017",
    "postTags": "AngularJS | React | Coding | Javascript",
    "postSnippet": "A lot of people use open source libraries without understanding the nuts and bolts. On the surface this may seem fine. You read its description, it says it will do what you need so you give integrating it into your project a shot. It does not work. Read the source code...",
    "postBody": "<div> <p> A lot of people use open source libraries without understanding the nuts and bolts. On the surface this may seem fine. You read its description, it says it will do what you need so you give integrating it into your project a shot. It does not work. It said it was going to, but there is something wrong. You did not write it so you cannot adequately debug it. </p> <p> This is the part that I love. I actually do it before using a library. Read the source code. Figure out exactly what the function/class is supposed to do. The context in which it is used, the arguments it needs, the calculations, the comments(if there are any). Once you read the source code, if it is written well or even if it is not, you will understand and be able to determine if the library is really what you need. </p> </div>"
  }
]